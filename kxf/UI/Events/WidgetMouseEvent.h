#pragma once
#include "WidgetEvent.h"
class wxMouseEvent;

namespace kxf
{
	class KX_API WidgetMouseEvent: public WidgetEvent
	{
		public:
			KxEVENT_MEMBER(WidgetMouseEvent, LeftUp);
			KxEVENT_MEMBER(WidgetMouseEvent, LeftDown);
			KxEVENT_MEMBER(WidgetMouseEvent, LeftDoubleClick);

			KxEVENT_MEMBER(WidgetMouseEvent, RightUp);
			KxEVENT_MEMBER(WidgetMouseEvent, RightDown);
			KxEVENT_MEMBER(WidgetMouseEvent, RightDoubleClick);

			KxEVENT_MEMBER(WidgetMouseEvent, MiddleUp);
			KxEVENT_MEMBER(WidgetMouseEvent, MiddleDown);
			KxEVENT_MEMBER(WidgetMouseEvent, MiddleDoubleClick);

			KxEVENT_MEMBER(WidgetMouseEvent, Aux1Up);
			KxEVENT_MEMBER(WidgetMouseEvent, Aux1Down);
			KxEVENT_MEMBER(WidgetMouseEvent, Aux1DoubleClick);

			KxEVENT_MEMBER(WidgetMouseEvent, Aux2Up);
			KxEVENT_MEMBER(WidgetMouseEvent, Aux2Down);
			KxEVENT_MEMBER(WidgetMouseEvent, Aux2DoubleClick);

			KxEVENT_MEMBER(WidgetMouseEvent, Move);
			KxEVENT_MEMBER(WidgetMouseEvent, Wheel);
			KxEVENT_MEMBER(WidgetMouseEvent, Magnification);

			KxEVENT_MEMBER(WidgetMouseEvent, Enter);
			KxEVENT_MEMBER(WidgetMouseEvent, Leave);

		private:
			KeyboardState m_KeyboardState;
			MouseState m_MouseState;

			int m_ClickCount = 0;
			int m_LinesPerAction = 0;
			int m_ColumnsPerAction = 0;
			float m_Magnification = 0.0f;

			int m_WheelDelta = 0;
			int m_WheelRotation = 0;
			bool m_WheelInverted = false;
			Orientation m_WheelAxis = Orientation::None;

		public:
			WidgetMouseEvent() noexcept = default;
			WidgetMouseEvent(IWidget& widget, const wxMouseEvent& mouseEventWX) noexcept;

		public:
			// IEvent
			std::unique_ptr<IEvent> Move() noexcept override
			{
				return std::make_unique<WidgetMouseEvent>(std::move(*this));
			}
			FlagSet<EventCategory> GetEventCategory() const noexcept override
			{
				return EventCategory::UserInput;
			}

		public:
			// WidgetMouseEvent
			MouseState GetMouseState() const noexcept
			{
				return m_MouseState;
			}
			KeyboardState GetKeyboardState() const noexcept
			{
				return m_KeyboardState;
			}
			Point GetPosition() const noexcept
			{
				return m_MouseState.GetPosition();
			}

			// Was it a up event from this (or any) button?
			bool IsButtonUp(MouseButton button = MouseButton::Any) const;

			// Was it a down event from this (or any) button?
			bool IsButtonDown(MouseButton button = MouseButton::Any) const;

			// Was it a double click event from this (or any) button?
			bool IsDoubleClick(MouseButton button = MouseButton::Any) const;

			// Was this event generated by the given button?
			bool IsButton(MouseButton button = MouseButton::Any) const noexcept;

			// Get the button which is changing state (wxMOUSE_BTN_NONE if none)
			MouseButton GetButton() const noexcept;

			// Find which event was just generated
			bool IsLeftUp() const noexcept
			{
				return GetEventID() == EvtLeftUp;
			}
			bool IsRightUp() const noexcept
			{
				return GetEventID() == EvtRightUp;
			}
			bool IsMiddleUp() const noexcept
			{
				return GetEventID() == EvtMiddleUp;
			}
			bool IsAux1Up() const noexcept
			{
				return GetEventID() == EvtAux1Up;
			}
			bool IsAux2Up() const noexcept
			{
				return GetEventID() == EvtAux2Up;
			}

			bool IsLeftDown() const noexcept
			{
				return GetEventID() == EvtLeftDown;
			}
			bool IsRightDown() const noexcept
			{
				return GetEventID() == EvtRightDown;
			}
			bool IsMiddleDown() const noexcept
			{
				return GetEventID() == EvtMiddleDown;
			}
			bool IsAux1Down() const noexcept
			{
				return GetEventID() == EvtAux1Down;
			}
			bool IsAux2Down() const noexcept
			{
				return GetEventID() == EvtAux2Down;
			}

			bool IsLeftDoubleClick() const noexcept
			{
				return GetEventID() == EvtLeftDoubleClick;
			}
			bool IsRightDoubleClick() const noexcept
			{
				return GetEventID() == EvtRightDoubleClick;
			}
			bool IsMiddleDoubleClick() const noexcept
			{
				return GetEventID() == EvtMiddleDoubleClick;
			}
			bool IsAux1DoubleClick() const noexcept
			{
				return GetEventID() == EvtAux1DoubleClick;
			}
			bool IsAux2DoubleClick() const noexcept
			{
				return GetEventID() == EvtAux2DoubleClick;
			}

			bool IsMagnification() const noexcept
			{
				return GetEventID() == EvtMagnification;
			}
			bool IsDragging() const noexcept
			{
				return GetEventID() == EvtMove && IsButtonDown();
			}
			bool IsMoving() const noexcept
			{
				return GetEventID() == EvtMove && !IsButtonDown();
			}

			bool IsEntering() const noexcept
			{
				return GetEventID() == EvtEnter;
			}
			bool IsLeaving() const noexcept
			{
				return GetEventID() == EvtLeave;
			}

		public:
			int GetClickCount() const noexcept
			{
				return m_ClickCount;
			}

			// Get wheel rotation, positive or negative indicates direction of
			// rotation. Current devices all send an event when rotation is equal to
			// +/-WheelDelta, but this allows for finer resolution devices to be
			// created in the future. Because of this you shouldn't assume that one
			// event is equal to 1 line or whatever, but you should be able to either
			// do partial line scrolling or wait until +/-WheelDelta rotation values
			// have been accumulated before scrolling.
			int GetWheelRotation() const
			{
				return m_WheelRotation;
			}

			// Get wheel delta, normally 120. This is the threshold for action to be taken,
			// and one such action (for example, scrolling one increment) should occur for each delta.
			int GetWheelDelta() const
			{
				return m_WheelDelta;
			}

			// On Mac, has the user selected "Natural" scrolling in their System Preferences? Currently false on all other platforms.
			bool IsWheelInverted() const
			{
				return m_WheelInverted;
			}

			// Gets the axis the wheel operation.
			Orientation GetWheelAxis() const
			{
				return m_WheelAxis;
			}

			// Returns the configured number of lines and columns to be scrolled per wheel action. Defaults to 3.
			int GetLinesPerAction() const
			{
				return m_LinesPerAction;
			}
			int GetColumnsPerAction() const
			{
				return m_ColumnsPerAction;
			}

			// Is the system set to do page scrolling?
			bool IsPageScroll() const noexcept
			{
				return m_LinesPerAction > 0 && static_cast<uint32_t>(m_LinesPerAction) == std::numeric_limits<uint32_t>::max();
			}

			float GetMagnification() const noexcept
			{
				return m_Magnification;
			}
	};
}
